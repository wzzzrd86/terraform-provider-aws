// Code generated by tools/tfsdk2fw/main.go. Manual editing is required.

package rds

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/rds"
	"github.com/hashicorp/aws-sdk-go-base/v2/awsv1shim/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/float64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/resourcevalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	sdkresource "github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwboolplanmodifier "github.com/hashicorp/terraform-provider-aws/internal/framework/boolplanmodifier"
	fwint64planmodifier "github.com/hashicorp/terraform-provider-aws/internal/framework/int64planmodifier"
	fwstringplanmodifier "github.com/hashicorp/terraform-provider-aws/internal/framework/stringplanmodifier"
	fwvalidators "github.com/hashicorp/terraform-provider-aws/internal/framework/validators"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)

func init() {
	_sp.registerFrameworkResourceFactory(newResourceCluster)
}

// newResourceCluster instantiates a new Resource for the aws_rds_cluster resource.
func newResourceCluster(context.Context) (resource.ResourceWithConfigure, error) {
	r := &resourceCluster{}
	r.SetMigratedFromPluginSDK(true)
	r.SetDefaultCreateTimeout(120 * time.Minute)
	r.SetDefaultUpdateTimeout(120 * time.Minute)
	r.SetDefaultDeleteTimeout(120 * time.Minute)

	return r, nil
}

const (
	ResNameCluster = "Cluster"
)

type resourceCluster struct {
	framework.ResourceWithConfigure
	framework.WithTimeouts
}

// Metadata should return the full name of the resource, such as
// examplecloud_thing.
func (r *resourceCluster) Metadata(_ context.Context, request resource.MetadataRequest, response *resource.MetadataResponse) {
	response.TypeName = "aws_rds_cluster"
}

// Schema returns the schema for this resource.
func (r *resourceCluster) Schema(ctx context.Context, request resource.SchemaRequest, response *resource.SchemaResponse) {
	s := schema.Schema{
		Attributes: map[string]schema.Attribute{
			"allocated_storage": schema.Int64Attribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"allow_major_version_upgrade": schema.BoolAttribute{
				Optional: true,
			},
			"apply_immediately": schema.BoolAttribute{
				Optional: true,
			},
			"arn": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"availability_zones": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.RequiresReplace(),
				},
			},
			"backtrack_window": schema.Int64Attribute{
				Optional: true,
				Computed: true,
				Validators: []validator.Int64{
					int64validator.Between(0, 259200),
				},
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"backup_retention_period": schema.Int64Attribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					fwint64planmodifier.DefaultValue(1),
					int64planmodifier.UseStateForUnknown(),
				},
				Validators: []validator.Int64{
					int64validator.AtMost(35),
				},
			},
			"cluster_identifier": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					fwvalidators.ClusterIdentifier(),
				},
			},
			"cluster_identifier_prefix": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					fwvalidators.ClusterIdentifierPrefix(),
				},
			},
			"cluster_members": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
			},
			"cluster_resource_id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"copy_tags_to_snapshot": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					fwboolplanmodifier.DefaultValue(false),
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"database_name": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"db_cluster_instance_class": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"db_cluster_parameter_group_name": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"db_instance_parameter_group_name": schema.StringAttribute{
				Optional: true,
			},
			"db_subnet_group_name": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"deletion_protection": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"enable_global_write_forwarding": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					fwboolplanmodifier.DefaultValue(false),
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"enable_http_endpoint": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					fwboolplanmodifier.DefaultValue(false),
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"enabled_cloudwatch_logs_exports": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.Set{
					setvalidator.ValueStringsAre(stringvalidator.OneOf(ClusterExportableLogType_Values()...)),
				},
			},
			"endpoint": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"engine": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					fwstringplanmodifier.DefaultValue(ClusterEngineAurora),
				},
				Validators: []validator.String{
					stringvalidator.OneOf(ClusterEngine_Values()...),
				},
			},
			"engine_mode": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					fwstringplanmodifier.DefaultValue(EngineModeProvisioned),
				},
				Validators: []validator.String{
					stringvalidator.OneOf(EngineMode_Values()...),
				},
			},
			"engine_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"engine_version_actual": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"final_snapshot_identifier": schema.StringAttribute{
				Optional: true,
				Validators: []validator.String{
					fwvalidators.ClusterFinalSnapshotIdentifier(),
				},
			},
			"global_cluster_identifier": schema.StringAttribute{
				Optional: true,
			},
			"hosted_zone_id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"iam_database_authentication_enabled": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"iam_roles": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
			},
			"id": framework.IDAttribute(),
			"iops": schema.Int64Attribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"kms_key_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"master_password": schema.StringAttribute{
				Optional:  true,
				Sensitive: true,
			},
			"master_username": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"network_type": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(NetworkType_Values()...),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"option_group_name": schema.StringAttribute{
				Optional: true,
			},
			"port": schema.Int64Attribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"preferred_backup_window": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				// TODO Validate,
			},
			"preferred_maintenance_window": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				// TODO Validate,
			},
			"reader_endpoint": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"replication_source_identifier": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"skip_final_snapshot": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					fwboolplanmodifier.DefaultValue(false),
				},
			},
			"snapshot_identifier": schema.StringAttribute{
				Optional: true,
			},
			"source_region": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"storage_encrypted": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"storage_type": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"tags":     tftags.TagsAttribute(),
			"tags_all": tftags.TagsAttributeComputedOnly(),
			"vpc_security_group_ids": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"restore_to_point_in_time": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"restore_to_time": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
							Validators: []validator.String{
								fwvalidators.UTCTimestamp(),
							},
						},
						"restore_type": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf(RestoreType_Values()...),
							},
						},
						"source_cluster_identifier": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
							Validators: []validator.String{
								stringvalidator.Any(
									fwvalidators.ClusterIdentifier(),
									// TODO need ARN validator
								),
							},
						},
						"use_latest_restorable_time": schema.BoolAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.Bool{
								boolplanmodifier.RequiresReplace(),
							},
						},
					},
				},
				Validators: []validator.List{
					listvalidator.SizeAtMost(1),
				},
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},
			},
			"s3_import": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"bucket_name": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"bucket_prefix": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"ingestion_role": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"source_engine": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"source_engine_version": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
					},
				},
				Validators: []validator.List{
					listvalidator.SizeAtMost(1),
				},
			},
			"scaling_configuration": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"auto_pause": schema.BoolAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.Bool{
								fwboolplanmodifier.DefaultValue(true),
							},
						},
						"max_capacity": schema.Int64Attribute{
							Optional: true,
							PlanModifiers: []planmodifier.Int64{
								fwint64planmodifier.DefaultValue(clusterScalingConfiguration_DefaultMaxCapacity),
							},
						},
						"min_capacity": schema.Int64Attribute{
							Optional: true,
							PlanModifiers: []planmodifier.Int64{
								fwint64planmodifier.DefaultValue(clusterScalingConfiguration_DefaultMinCapacity),
							},
						},
						"seconds_until_auto_pause": schema.Int64Attribute{
							Optional: true,
							PlanModifiers: []planmodifier.Int64{
								fwint64planmodifier.DefaultValue(300),
							},
							Validators: []validator.Int64{
								int64validator.Between(300, 86400),
							},
						},
						"timeout_action": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								fwstringplanmodifier.DefaultValue(TimeoutActionRollbackCapacityChange),
							},
							Validators: []validator.String{
								stringvalidator.OneOf(TimeoutAction_Values()...),
							},
						},
					},
				},
				Validators: []validator.List{
					listvalidator.SizeAtMost(1),
				},
			},
			"serverlessv2_scaling_configuration": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"max_capacity": schema.Float64Attribute{
							Required: true,
							Validators: []validator.Float64{
								float64validator.Between(0.5, 128),
							},
						},
						"min_capacity": schema.Float64Attribute{
							Required: true,
							Validators: []validator.Float64{
								float64validator.Between(0.5, 128),
							},
						},
					},
				},
				Validators: []validator.List{
					listvalidator.SizeAtMost(1),
				},
			},
		},
	}

	if s.Blocks == nil {
		s.Blocks = make(map[string]schema.Block)
	}
	s.Blocks["timeouts"] = timeouts.Block(ctx, timeouts.Opts{
		Create: true,
		Update: true,
		Delete: true,
	})

	response.Schema = s
}

// Create is called when the provider must create a new resource.
// Config and planned state values should be read from the CreateRequest and new state values set on the CreateResponse.
func (r *resourceCluster) Create(ctx context.Context, request resource.CreateRequest, response *resource.CreateResponse) {
	var data resourceClusterData
	conn := r.Meta().RDSConn()

	defaultTagsConfig := r.Meta().DefaultTagsConfig
	ignoreTagsConfig := r.Meta().IgnoreTagsConfig
	tags := defaultTagsConfig.MergeTags(tftags.New(data.Tags))
	data.TagsAll = flex.FlattenFrameworkStringValueMapLegacy(ctx, tags.IgnoreAWS().IgnoreConfig(ignoreTagsConfig).Map())

	response.Diagnostics.Append(request.Plan.Get(ctx, &data)...)

	if response.Diagnostics.HasError() {
		return
	}
	createTimeout := r.CreateTimeout(ctx, data.Timeouts)

	var requiresModifyDbCluster bool
	modifyDbClusterInput := &rds.ModifyDBClusterInput{
		ApplyImmediately: aws.Bool(true),
	}

	var identifier string
	if !data.ClusterIdentifier.IsUnknown() && !data.ClusterIdentifier.IsNull() {
		identifier = data.ClusterIdentifier.ValueString()
	} else if !data.ClusterIdentifierPrefix.IsUnknown() && !data.ClusterIdentifierPrefix.IsNull() {
		identifier = sdkresource.PrefixedUniqueId(data.ClusterIdentifierPrefix.ValueString())
	} else {
		identifier = sdkresource.PrefixedUniqueId("tf-")
	}

	if !data.SnapshotIdentifier.IsUnknown() && !data.SnapshotIdentifier.IsNull() {
		input := &rds.RestoreDBClusterFromSnapshotInput{
			CopyTagsToSnapshot:  aws.Bool(data.CopyTagsToSnapshot.ValueBool()),
			DBClusterIdentifier: aws.String(identifier),
			DeletionProtection:  aws.Bool(data.DeletionProtection.ValueBool()),
			Engine:              aws.String(data.Engine.ValueString()),
			EngineMode:          aws.String(data.EngineMode.ValueString()),
			Tags:                Tags(tags.IgnoreAWS()),
		}

		if !data.AvailabilityZones.IsUnknown() && !data.AvailabilityZones.IsNull() {
			input.AvailabilityZones = flex.ExpandFrameworkStringSet(ctx, data.AvailabilityZones)
		}

		if !data.BacktrackWindow.IsUnknown() && !data.BacktrackWindow.IsNull() {
			input.BacktrackWindow = aws.Int64(data.BacktrackWindow.ValueInt64())
		}

		if !data.BackupRetentionPeriod.IsNull() {
			modifyDbClusterInput.BackupRetentionPeriod = aws.Int64(data.BackupRetentionPeriod.ValueInt64())
			requiresModifyDbCluster = true
		}

		if !data.DatabaseName.IsUnknown() && !data.DatabaseName.IsNull() {
			input.DatabaseName = aws.String(data.DatabaseName.ValueString())
		}

		if !data.DbClusterParameterGroupName.IsUnknown() && !data.DbClusterParameterGroupName.IsNull() {
			input.DBClusterParameterGroupName = aws.String(data.DbClusterParameterGroupName.ValueString())
		}

		if !data.DbSubnetGroupName.IsUnknown() && !data.DbSubnetGroupName.IsNull() {
			input.DBSubnetGroupName = aws.String(data.DbSubnetGroupName.ValueString())
		}

		if !data.EnabledCloudwatchLogsExports.IsNull() {
			input.EnableCloudwatchLogsExports = flex.ExpandFrameworkStringSet(ctx, data.EnabledCloudwatchLogsExports)
		}

		if !data.EngineVersion.IsUnknown() && !data.EngineVersion.IsNull() {
			input.EngineVersion = aws.String(data.EngineVersion.ValueString())
		}

		if !data.KmsKeyID.IsUnknown() && !data.KmsKeyID.IsNull() {
			input.KmsKeyId = aws.String(data.KmsKeyID.ValueString())
		}

		if !data.MasterPassword.IsNull() {
			modifyDbClusterInput.MasterUserPassword = aws.String(data.MasterPassword.ValueString())
			requiresModifyDbCluster = true
		}

		if !data.NetworkType.IsUnknown() && !data.NetworkType.IsNull() {
			input.NetworkType = aws.String(data.NetworkType.ValueString())
		}

		if !data.OptionGroupName.IsUnknown() && !data.OptionGroupName.IsNull() {
			input.OptionGroupName = aws.String(data.OptionGroupName.ValueString())
		}

		if !data.Port.IsUnknown() && !data.Port.IsNull() {
			input.Port = aws.Int64(data.Port.ValueInt64())
		}

		if !data.PreferredBackupWindow.IsUnknown() && !data.PreferredBackupWindow.IsNull() {
			modifyDbClusterInput.PreferredBackupWindow = aws.String(data.PreferredBackupWindow.ValueString())
			requiresModifyDbCluster = true
		}

		if !data.PreferredMaintenanceWindow.IsUnknown() && !data.PreferredMaintenanceWindow.IsNull() {
			modifyDbClusterInput.PreferredMaintenanceWindow = aws.String(data.PreferredMaintenanceWindow.ValueString())
			requiresModifyDbCluster = true
		}

		var scalingConfiguration []scalingConfiguration
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &scalingConfiguration, false)...)
		if response.Diagnostics.HasError() {
			return
		}
		input.ScalingConfiguration = expandScalingConfigurationFramework(scalingConfiguration)

		var serverlessV2ScalingConfiguration []serverlessV2ScalingConfiguration
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &serverlessV2ScalingConfiguration, false)...)
		if response.Diagnostics.HasError() {
			return
		}
		input.ServerlessV2ScalingConfiguration = expandServerlessV2ScalingConfigurationFramework(serverlessV2ScalingConfiguration)

		if !data.VpcSecurityGroupIds.IsUnknown() && !data.VpcSecurityGroupIds.IsNull() {
			input.VpcSecurityGroupIds = flex.ExpandFrameworkStringSet(ctx, data.VpcSecurityGroupIds)
		}

		_, err := tfresource.RetryWhenAWSErrMessageContains(ctx, propagationTimeout,
			func() (interface{}, error) {
				return conn.RestoreDBClusterFromSnapshotWithContext(ctx, input)
			},
			errCodeInvalidParameterValue, "IAM role ARN value is invalid or does not include the required permissions")

		if err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionCreating, ResNameCluster, identifier, nil),
				err.Error(),
			)
			return
		}
	} else if !data.S3Import.IsNull() && len(data.S3Import.Elements()) > 0 {
		var s3Import []s3Import
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &s3Import, false)...)
		if response.Diagnostics.HasError() {
			return
		}

		importValues := s3Import[0]
		input := &rds.RestoreDBClusterFromS3Input{
			CopyTagsToSnapshot:  aws.Bool(data.CopyTagsToSnapshot.ValueBool()),
			DBClusterIdentifier: aws.String(identifier),
			DeletionProtection:  aws.Bool(data.DeletionProtection.ValueBool()),
			Engine:              aws.String(data.Engine.ValueString()),
			MasterUsername:      aws.String(data.MasterUsername.ValueString()),
			MasterUserPassword:  aws.String(data.MasterPassword.ValueString()),
			S3BucketName:        aws.String(importValues.BucketName.ValueString()),
			S3IngestionRoleArn:  aws.String(importValues.IngestionRole.ValueString()),
			S3Prefix:            aws.String(importValues.BucketPrefix.ValueString()),
			SourceEngine:        aws.String(importValues.SourceEngine.ValueString()),
			SourceEngineVersion: aws.String(importValues.SourceEngineVersion.ValueString()),
			Tags:                Tags(tags.IgnoreAWS()),
		}

		if !data.AvailabilityZones.IsUnknown() && !data.AvailabilityZones.IsNull() {
			input.AvailabilityZones = flex.ExpandFrameworkStringSet(ctx, data.AvailabilityZones)
		}

		if !data.BacktrackWindow.IsUnknown() && !data.BacktrackWindow.IsNull() {
			input.BacktrackWindow = aws.Int64(data.BacktrackWindow.ValueInt64())
		}

		if !data.BackupRetentionPeriod.IsNull() {
			input.BackupRetentionPeriod = aws.Int64(data.BackupRetentionPeriod.ValueInt64())
		}

		if !data.DatabaseName.IsUnknown() && !data.DatabaseName.IsNull() {
			input.DatabaseName = aws.String(data.DatabaseName.ValueString())
		}

		if !data.DbClusterParameterGroupName.IsUnknown() && !data.DbClusterParameterGroupName.IsNull() {
			input.DBClusterParameterGroupName = aws.String(data.DbClusterParameterGroupName.ValueString())
		}

		if !data.DbSubnetGroupName.IsUnknown() && !data.DbSubnetGroupName.IsNull() {
			input.DBSubnetGroupName = aws.String(data.DbSubnetGroupName.ValueString())
		}

		if !data.EnabledCloudwatchLogsExports.IsNull() {
			input.EnableCloudwatchLogsExports = flex.ExpandFrameworkStringSet(ctx, data.EnabledCloudwatchLogsExports)
		}

		if !data.EngineVersion.IsUnknown() && !data.EngineVersion.IsNull() {
			input.EngineVersion = aws.String(data.EngineVersion.ValueString())
		}

		if !data.IamDatabaseAuthenticationEnabled.IsUnknown() && !data.IamDatabaseAuthenticationEnabled.IsNull() {
			input.EnableIAMDatabaseAuthentication = aws.Bool(data.IamDatabaseAuthenticationEnabled.ValueBool())
		}

		if !data.KmsKeyID.IsUnknown() && !data.KmsKeyID.IsNull() {
			input.KmsKeyId = aws.String(data.KmsKeyID.ValueString())
		}

		if !data.NetworkType.IsUnknown() && !data.NetworkType.IsNull() {
			input.NetworkType = aws.String(data.NetworkType.ValueString())
		}

		if !data.Port.IsUnknown() && !data.Port.IsNull() {
			input.Port = aws.Int64(data.Port.ValueInt64())
		}

		if !data.PreferredBackupWindow.IsUnknown() && !data.PreferredBackupWindow.IsNull() {
			input.PreferredBackupWindow = aws.String(data.PreferredBackupWindow.ValueString())
		}

		if !data.PreferredMaintenanceWindow.IsUnknown() && !data.PreferredMaintenanceWindow.IsNull() {
			input.PreferredMaintenanceWindow = aws.String(data.PreferredMaintenanceWindow.ValueString())
		}

		if !data.StorageEncrypted.IsUnknown() && !data.StorageEncrypted.IsNull() {
			input.StorageEncrypted = aws.Bool(data.StorageEncrypted.ValueBool())
		}

		if !data.VpcSecurityGroupIds.IsUnknown() && !data.VpcSecurityGroupIds.IsNull() {
			input.VpcSecurityGroupIds = flex.ExpandFrameworkStringSet(ctx, data.VpcSecurityGroupIds)
		}

		_, err := tfresource.RetryWhen(ctx, propagationTimeout,
			func() (interface{}, error) {
				return conn.RestoreDBClusterFromS3WithContext(ctx, input)
			},
			func(err error) (bool, error) {
				// InvalidParameterValue: Files from the specified Amazon S3 bucket cannot be downloaded.
				// Make sure that you have created an AWS Identity and Access Management (IAM) role that lets Amazon RDS access Amazon S3 for you.
				if tfawserr.ErrMessageContains(err, errCodeInvalidParameterValue, "Files from the specified Amazon S3 bucket cannot be downloaded") {
					return true, err
				}

				if tfawserr.ErrMessageContains(err, errCodeInvalidParameterValue, "S3_SNAPSHOT_INGESTION") {
					return true, err
				}

				if tfawserr.ErrMessageContains(err, errCodeInvalidParameterValue, "S3 bucket cannot be found") {
					return true, err
				}

				return false, err
			},
		)

		if err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionCreating, ResNameCluster, identifier, nil),
				err.Error(),
			)
			return
		}
	} else if !data.RestoreToPointInTime.IsNull() && len(data.RestoreToPointInTime.Elements()) > 0 {
		var restoreToPointInTime []restoreToPointInTime
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &restoreToPointInTime, false)...)
		if response.Diagnostics.HasError() {
			return
		}

		m := restoreToPointInTime[0]
		input := &rds.RestoreDBClusterToPointInTimeInput{
			DBClusterIdentifier:       aws.String(identifier),
			DeletionProtection:        aws.Bool(data.DeletionProtection.ValueBool()),
			SourceDBClusterIdentifier: aws.String(m.SourceClusterIdentifier.ValueString()),
			Tags:                      Tags(tags.IgnoreAWS()),
		}

		if !m.RestoreToTime.IsNull() {
			v, _ := time.Parse(time.RFC3339, m.RestoreToTime.ValueString())
			input.RestoreToTime = aws.Time(v)
		}

		if !m.UseLatestRestorableTime.IsNull() {
			input.UseLatestRestorableTime = aws.Bool(m.UseLatestRestorableTime.ValueBool())
		}

		if !data.BacktrackWindow.IsUnknown() && !data.BacktrackWindow.IsNull() {
			input.BacktrackWindow = aws.Int64(data.BacktrackWindow.ValueInt64())
		}

		if !data.BackupRetentionPeriod.IsNull() {
			modifyDbClusterInput.BackupRetentionPeriod = aws.Int64(data.BackupRetentionPeriod.ValueInt64())
			requiresModifyDbCluster = true
		}

		if !data.DbClusterParameterGroupName.IsUnknown() && !data.DbClusterParameterGroupName.IsNull() {
			input.DBClusterParameterGroupName = aws.String(data.DbClusterParameterGroupName.ValueString())
		}

		if !data.DbSubnetGroupName.IsUnknown() && !data.DbSubnetGroupName.IsNull() {
			input.DBSubnetGroupName = aws.String(data.DbSubnetGroupName.ValueString())
		}

		if !data.EnabledCloudwatchLogsExports.IsNull() {
			input.EnableCloudwatchLogsExports = flex.ExpandFrameworkStringSet(ctx, data.EnabledCloudwatchLogsExports)
		}

		if !data.IamDatabaseAuthenticationEnabled.IsUnknown() && !data.IamDatabaseAuthenticationEnabled.IsNull() {
			input.EnableIAMDatabaseAuthentication = aws.Bool(data.IamDatabaseAuthenticationEnabled.ValueBool())
		}

		if !data.KmsKeyID.IsUnknown() && !data.KmsKeyID.IsNull() {
			input.KmsKeyId = aws.String(data.KmsKeyID.ValueString())
		}

		if !data.NetworkType.IsUnknown() && !data.NetworkType.IsNull() {
			input.NetworkType = aws.String(data.NetworkType.ValueString())
		}

		if !data.MasterPassword.IsNull() {
			modifyDbClusterInput.MasterUserPassword = aws.String(data.MasterPassword.ValueString())
			requiresModifyDbCluster = true
		}

		if !data.OptionGroupName.IsUnknown() && !data.OptionGroupName.IsNull() {
			input.OptionGroupName = aws.String(data.OptionGroupName.ValueString())
		}

		if !data.Port.IsUnknown() && !data.Port.IsNull() {
			input.Port = aws.Int64(data.Port.ValueInt64())
		}

		if !data.PreferredBackupWindow.IsUnknown() && !data.PreferredBackupWindow.IsNull() {
			modifyDbClusterInput.PreferredBackupWindow = aws.String(data.PreferredBackupWindow.ValueString())
			requiresModifyDbCluster = true
		}

		if !data.PreferredMaintenanceWindow.IsUnknown() && !data.PreferredMaintenanceWindow.IsNull() {
			modifyDbClusterInput.PreferredMaintenanceWindow = aws.String(data.PreferredMaintenanceWindow.ValueString())
			requiresModifyDbCluster = true
		}

		if !m.RestoreType.IsNull() {
			input.RestoreType = aws.String(m.RestoreType.ValueString())
		}

		var scalingConfiguration []scalingConfiguration
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &scalingConfiguration, false)...)
		if response.Diagnostics.HasError() {
			return
		}
		input.ScalingConfiguration = expandScalingConfigurationFramework(scalingConfiguration)

		var serverlessV2ScalingConfiguration []serverlessV2ScalingConfiguration
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &serverlessV2ScalingConfiguration, false)...)
		if response.Diagnostics.HasError() {
			return
		}
		input.ServerlessV2ScalingConfiguration = expandServerlessV2ScalingConfigurationFramework(serverlessV2ScalingConfiguration)

		if !data.VpcSecurityGroupIds.IsUnknown() && !data.VpcSecurityGroupIds.IsNull() {
			input.VpcSecurityGroupIds = flex.ExpandFrameworkStringSet(ctx, data.VpcSecurityGroupIds)
		}

		_, err := conn.RestoreDBClusterToPointInTimeWithContext(ctx, input)

		if err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionCreating, ResNameCluster, identifier, nil),
				err.Error(),
			)
			return
		}
	} else {
		input := &rds.CreateDBClusterInput{
			CopyTagsToSnapshot:  aws.Bool(data.CopyTagsToSnapshot.ValueBool()),
			DBClusterIdentifier: aws.String(identifier),
			DeletionProtection:  aws.Bool(data.DeletionProtection.ValueBool()),
			Engine:              aws.String(data.Engine.ValueString()),
			EngineMode:          aws.String(data.EngineMode.ValueString()),
			Tags:                Tags(tags.IgnoreAWS()),
		}

		if !data.AllocatedStorage.IsUnknown() && !data.AllocatedStorage.IsNull() {
			input.AllocatedStorage = aws.Int64(data.AllocatedStorage.ValueInt64())
		}

		if !data.AvailabilityZones.IsUnknown() && !data.AvailabilityZones.IsNull() {
			input.AvailabilityZones = flex.ExpandFrameworkStringSet(ctx, data.AvailabilityZones)
		}

		if !data.BacktrackWindow.IsUnknown() && !data.BacktrackWindow.IsNull() {
			input.BacktrackWindow = aws.Int64(data.BacktrackWindow.ValueInt64())
		}

		if !data.BackupRetentionPeriod.IsNull() {
			input.BackupRetentionPeriod = aws.Int64(data.BackupRetentionPeriod.ValueInt64())
		}

		if !data.DatabaseName.IsUnknown() && !data.DatabaseName.IsNull() {
			input.DatabaseName = aws.String(data.DatabaseName.ValueString())
		}

		if !data.DbClusterInstanceClass.IsUnknown() && !data.DbClusterInstanceClass.IsNull() {
			input.DBClusterInstanceClass = aws.String(data.DbClusterInstanceClass.ValueString())
		}

		if !data.DbClusterParameterGroupName.IsUnknown() && !data.DbClusterParameterGroupName.IsNull() {
			input.DBClusterParameterGroupName = aws.String(data.DbClusterParameterGroupName.ValueString())
		}

		if !data.DbSubnetGroupName.IsUnknown() && !data.DbSubnetGroupName.IsNull() {
			input.DBSubnetGroupName = aws.String(data.DbSubnetGroupName.ValueString())
		}

		//if !data.EnableGlobalWriteForwarding.IsUnknown() && !data.EnableGlobalWriteForwarding.IsNull() {
		//	input.EnableGlobalWriteForwarding = aws.Bool(data.EnableGlobalWriteForwarding.ValueBool())
		//}

		if !data.EnableHttpEndpoint.IsNull() {
			input.EnableHttpEndpoint = aws.Bool(data.EnableHttpEndpoint.ValueBool())
		}

		if !data.EnabledCloudwatchLogsExports.IsNull() {
			input.EnableCloudwatchLogsExports = flex.ExpandFrameworkStringSet(ctx, data.EnabledCloudwatchLogsExports)
		}

		if !data.EngineVersion.IsUnknown() && !data.EngineVersion.IsNull() {
			input.EngineVersion = aws.String(data.EngineVersion.ValueString())
		}

		if !data.GlobalClusterIdentifier.IsNull() {
			input.GlobalClusterIdentifier = aws.String(data.GlobalClusterIdentifier.ValueString())
			input.EnableGlobalWriteForwarding = aws.Bool(data.EnableGlobalWriteForwarding.ValueBool())
		}

		if !data.IamDatabaseAuthenticationEnabled.IsUnknown() && !data.IamDatabaseAuthenticationEnabled.IsNull() {
			input.EnableIAMDatabaseAuthentication = aws.Bool(data.IamDatabaseAuthenticationEnabled.ValueBool())
		}

		if !data.Iops.IsUnknown() && !data.Iops.IsNull() {
			input.Iops = aws.Int64(data.Iops.ValueInt64())
		}

		if !data.KmsKeyID.IsUnknown() && !data.KmsKeyID.IsNull() {
			input.KmsKeyId = aws.String(data.KmsKeyID.ValueString())
		}

		// Note: Username and password credentials are required and valid
		// unless the cluster is a read-replica. This also applies to clusters
		// within a global cluster. Providing a password and/or username for
		// a replica will result in an InvalidParameterValue error.
		if !data.MasterPassword.IsNull() {
			input.MasterUserPassword = aws.String(data.MasterPassword.ValueString())
		}

		if !data.MasterUsername.IsNull() && !data.MasterUsername.IsUnknown() {
			input.MasterUsername = aws.String(data.MasterUsername.ValueString())
		}

		if !data.NetworkType.IsUnknown() && !data.NetworkType.IsNull() {
			input.NetworkType = aws.String(data.NetworkType.ValueString())
		}

		if !data.Port.IsUnknown() && !data.Port.IsNull() {
			input.Port = aws.Int64(data.Port.ValueInt64())
		}

		if !data.PreferredBackupWindow.IsUnknown() && !data.PreferredBackupWindow.IsNull() {
			input.PreferredBackupWindow = aws.String(data.PreferredBackupWindow.ValueString())
		}

		if !data.PreferredMaintenanceWindow.IsUnknown() && !data.PreferredMaintenanceWindow.IsNull() {
			input.PreferredMaintenanceWindow = aws.String(data.PreferredMaintenanceWindow.ValueString())
		}

		if !data.ReplicationSourceIdentifier.IsUnknown() && !data.ReplicationSourceIdentifier.IsNull() {
			input.ReplicationSourceIdentifier = aws.String(data.ReplicationSourceIdentifier.ValueString())
		}

		var scalingConfiguration []scalingConfiguration
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &scalingConfiguration, false)...)
		if response.Diagnostics.HasError() {
			return
		}
		input.ScalingConfiguration = expandScalingConfigurationFramework(scalingConfiguration)

		var serverlessV2ScalingConfiguration []serverlessV2ScalingConfiguration
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &serverlessV2ScalingConfiguration, false)...)
		if response.Diagnostics.HasError() {
			return
		}
		input.ServerlessV2ScalingConfiguration = expandServerlessV2ScalingConfigurationFramework(serverlessV2ScalingConfiguration)

		if !data.SourceRegion.IsNull() {
			input.SourceRegion = aws.String(data.SourceRegion.ValueString())
		}

		if !data.StorageEncrypted.IsUnknown() && !data.StorageEncrypted.IsNull() {
			input.StorageEncrypted = aws.Bool(data.StorageEncrypted.ValueBool())
		}

		if !data.StorageType.IsUnknown() && !data.StorageType.IsNull() {
			input.StorageType = aws.String(data.StorageType.ValueString())
		}

		if !data.VpcSecurityGroupIds.IsUnknown() && !data.VpcSecurityGroupIds.IsNull() {
			input.VpcSecurityGroupIds = flex.ExpandFrameworkStringSet(ctx, data.VpcSecurityGroupIds)
		}

		_, err := tfresource.RetryWhenAWSErrMessageContains(ctx, propagationTimeout,
			func() (interface{}, error) {
				return conn.CreateDBClusterWithContext(ctx, input)
			},
			errCodeInvalidParameterValue, "IAM role ARN value is invalid or does not include the required permissions")

		if err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionCreating, ResNameCluster, identifier, nil),
				err.Error(),
			)
			return
		}
	}

	data.ID = types.StringValue(identifier)

	if _, err := waitDBClusterCreated(ctx, conn, data.ID.ValueString(), createTimeout); err != nil {
		response.Diagnostics.AddError(
			create.ProblemStandardMessage(names.RDS, create.ErrActionWaitingForCreation, ResNameCluster, data.ID.ValueString(), nil),
			err.Error(),
		)
		return
	}

	if !data.IamRoles.IsUnknown() && !data.IamRoles.IsNull() {
		roles := flex.ExpandFrameworkStringValueSet(ctx, data.IamRoles)
		for _, v := range roles {
			if err := addIAMRoleToCluster(ctx, conn, data.ID.ValueString(), v); err != nil {
				response.Diagnostics.AddError(
					fmt.Sprintf("adding IAM role (%s) to RDS Cluster (%s)", v, data.ID.ValueString()),
					err.Error(),
				)
				return
			}
		}
	}

	if requiresModifyDbCluster {
		modifyDbClusterInput.DBClusterIdentifier = aws.String(data.ID.ValueString())

		_, err := conn.ModifyDBClusterWithContext(ctx, modifyDbClusterInput)
		if err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionUpdating, ResNameCluster, data.ID.ValueString(), nil),
				err.Error(),
			)
			return
		}

		if _, err := waitDBClusterUpdated(ctx, conn, data.ID.ValueString(), createTimeout); err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionWaitingForUpdate, ResNameCluster, data.ID.ValueString(), nil),
				err.Error(),
			)
			return
		}
	}

	out, err := FindDBClusterByID(ctx, conn, data.ID.ValueString())

	if err != nil {
		response.Diagnostics.AddError(
			create.ProblemStandardMessage(names.RDS, create.ErrActionWaitingForUpdate, ResNameCluster, data.ID.ValueString(), nil),
			err.Error(),
		)
		return
	}

	state := data
	response.Diagnostics.Append(state.refreshFromOutput(ctx, r.Meta(), out)...)
	response.Diagnostics.Append(response.State.Set(ctx, &state)...)
}

// Read is called when the provider must read resource values in order to update state.
// Planned state values should be read from the ReadRequest and new state values set on the ReadResponse.
func (r *resourceCluster) Read(ctx context.Context, request resource.ReadRequest, response *resource.ReadResponse) {
	conn := r.Meta().RDSConn()

	var data resourceClusterData
	response.Diagnostics.Append(request.State.Get(ctx, &data)...)

	if response.Diagnostics.HasError() {
		return
	}

	out, err := FindDBClusterByID(ctx, conn, data.ID.ValueString())

	if tfresource.NotFound(err) {
		response.Diagnostics.AddWarning(
			"AWS Resource Not Found During Refresh",
			fmt.Sprintf("Automatically removing from Terraform State instead of returning the error, which may trigger resource recreation. Original Error: %s", err.Error()),
		)
		response.State.RemoveResource(ctx)
		return
	}

	if err != nil {
		response.Diagnostics.AddError(
			create.ProblemStandardMessage(names.RDS, create.ErrActionReading, ResNameCluster, data.ID.ValueString(), nil),
			err.Error(),
		)
		return
	}

	response.Diagnostics.Append(data.refreshFromOutput(ctx, r.Meta(), out)...)
	response.Diagnostics.Append(response.State.Set(ctx, &data)...)
}

// Update is called to update the state of the resource.
// Config, planned state, and prior state values should be read from the UpdateRequest and new state values set on the UpdateResponse.
func (r *resourceCluster) Update(ctx context.Context, request resource.UpdateRequest, response *resource.UpdateResponse) {
	conn := r.Meta().RDSConn()
	var plan, state resourceClusterData

	response.Diagnostics.Append(request.State.Get(ctx, &state)...)

	if response.Diagnostics.HasError() {
		return
	}

	response.Diagnostics.Append(request.Plan.Get(ctx, &plan)...)

	if response.Diagnostics.HasError() {
		return
	}
	updateTimeout := r.UpdateTimeout(ctx, plan.Timeouts)

	var modifyCluster bool
	input := &rds.ModifyDBClusterInput{
		ApplyImmediately:    aws.Bool(plan.ApplyImmediately.ValueBool()),
		DBClusterIdentifier: aws.String(plan.ID.ValueString()),
	}

	if !plan.AllocatedStorage.Equal(state.AllocatedStorage) {
		input.AllocatedStorage = aws.Int64(plan.AllocatedStorage.ValueInt64())
		modifyCluster = true
	}

	if !plan.AllowMajorVersionUpgrade.IsNull() {
		input.AllowMajorVersionUpgrade = aws.Bool(plan.AllowMajorVersionUpgrade.ValueBool())
		modifyCluster = true
	}

	if !plan.BacktrackWindow.Equal(state.BacktrackWindow) {
		input.BacktrackWindow = aws.Int64(plan.BacktrackWindow.ValueInt64())
		modifyCluster = true
	}

	if !plan.BackupRetentionPeriod.Equal(state.BackupRetentionPeriod) {
		input.BackupRetentionPeriod = aws.Int64(plan.BackupRetentionPeriod.ValueInt64())
		modifyCluster = true
	}

	if !plan.CopyTagsToSnapshot.Equal(state.CopyTagsToSnapshot) {
		input.CopyTagsToSnapshot = aws.Bool(plan.CopyTagsToSnapshot.ValueBool())
		modifyCluster = true
	}

	if !plan.DbClusterInstanceClass.Equal(state.DbClusterInstanceClass) {
		input.DBClusterInstanceClass = aws.String(plan.DbClusterInstanceClass.ValueString())
		modifyCluster = true
	}

	if !plan.DbClusterParameterGroupName.Equal(state.DbClusterParameterGroupName) {
		input.DBClusterParameterGroupName = aws.String(plan.DbClusterParameterGroupName.ValueString())
		modifyCluster = true
	}

	if !plan.DbInstanceParameterGroupName.Equal(state.DbInstanceParameterGroupName) {
		input.DBInstanceParameterGroupName = aws.String(plan.DbInstanceParameterGroupName.ValueString())
		modifyCluster = true
	}

	if !plan.DeletionProtection.Equal(state.DeletionProtection) {
		input.DeletionProtection = aws.Bool(plan.DeletionProtection.ValueBool())
		modifyCluster = true
	}

	if !plan.EnableGlobalWriteForwarding.Equal(state.EnableGlobalWriteForwarding) {
		input.EnableGlobalWriteForwarding = aws.Bool(plan.EnableGlobalWriteForwarding.ValueBool())
		modifyCluster = true
	}

	if !plan.EnableHttpEndpoint.Equal(state.EnableHttpEndpoint) {
		input.EnableHttpEndpoint = aws.Bool(plan.EnableHttpEndpoint.ValueBool())
		modifyCluster = true
	}

	if !plan.EnabledCloudwatchLogsExports.Equal(state.EnabledCloudwatchLogsExports) {
		o := flex.ExpandFrameworkStringValueSet(ctx, state.EnabledCloudwatchLogsExports)
		n := flex.ExpandFrameworkStringValueSet(ctx, state.EnabledCloudwatchLogsExports)

		input.CloudwatchLogsExportConfiguration = &rds.CloudwatchLogsExportConfiguration{
			DisableLogTypes: aws.StringSlice(o.Difference(n)),
			EnableLogTypes:  aws.StringSlice(n.Difference(o)),
		}
		modifyCluster = true
	}

	if !plan.EngineVersion.Equal(state.EngineVersion) {
		input.EngineVersion = aws.String(plan.EngineVersion.ValueString())
		modifyCluster = true
	}

	if !plan.IamDatabaseAuthenticationEnabled.Equal(state.IamDatabaseAuthenticationEnabled) {
		input.EnableIAMDatabaseAuthentication = aws.Bool(plan.IamDatabaseAuthenticationEnabled.ValueBool())
		modifyCluster = true
	}

	if !plan.Iops.Equal(state.Iops) {
		input.Iops = aws.Int64(plan.Iops.ValueInt64())
		modifyCluster = true
	}

	if !plan.MasterPassword.Equal(state.MasterPassword) {
		input.MasterUserPassword = aws.String(plan.MasterPassword.ValueString())
		modifyCluster = true
	}

	if !plan.NetworkType.Equal(state.NetworkType) {
		input.NetworkType = aws.String(plan.NetworkType.ValueString())
		modifyCluster = true
	}

	if !plan.Port.Equal(state.Port) {
		input.Port = aws.Int64(plan.Port.ValueInt64())
		modifyCluster = true
	}

	if !plan.PreferredBackupWindow.Equal(state.PreferredBackupWindow) {
		input.PreferredBackupWindow = aws.String(plan.PreferredBackupWindow.ValueString())
		modifyCluster = true
	}

	if !plan.PreferredMaintenanceWindow.Equal(state.PreferredMaintenanceWindow) {
		input.PreferredMaintenanceWindow = aws.String(plan.PreferredMaintenanceWindow.ValueString())
		modifyCluster = true
	}

	if !plan.ScalingConfiguration.Equal(state.ScalingConfiguration) {
		var scalingConfiguration []scalingConfiguration
		response.Diagnostics.Append(plan.ScalingConfiguration.ElementsAs(ctx, &scalingConfiguration, false)...)
		if response.Diagnostics.HasError() {
			return
		}
		input.ScalingConfiguration = expandScalingConfigurationFramework(scalingConfiguration)
		modifyCluster = true
	}

	if !plan.ServerlessV2ScalingConfiguration.Equal(state.ServerlessV2ScalingConfiguration) {
		var serverlessV2ScalingConfiguration []serverlessV2ScalingConfiguration
		response.Diagnostics.Append(plan.ScalingConfiguration.ElementsAs(ctx, &serverlessV2ScalingConfiguration, false)...)
		if response.Diagnostics.HasError() {
			return
		}
		input.ServerlessV2ScalingConfiguration = expandServerlessV2ScalingConfigurationFramework(serverlessV2ScalingConfiguration)
		modifyCluster = true
	}

	if !plan.StorageType.Equal(state.StorageType) {
		input.StorageType = aws.String(plan.StorageType.ValueString())
		modifyCluster = true
	}

	if !plan.VpcSecurityGroupIds.Equal(state.VpcSecurityGroupIds) {
		input.VpcSecurityGroupIds = flex.ExpandFrameworkStringSet(ctx, plan.VpcSecurityGroupIds)
		modifyCluster = true
	}

	if modifyCluster {
		_, err := tfresource.RetryWhen(ctx, 5*time.Minute,
			func() (interface{}, error) {
				return conn.ModifyDBClusterWithContext(ctx, input)
			},
			func(err error) (bool, error) {
				if tfawserr.ErrMessageContains(err, errCodeInvalidParameterValue, "IAM role ARN value is invalid or does not include the required permissions") {
					return true, err
				}

				if tfawserr.ErrCodeEquals(err, rds.ErrCodeInvalidDBClusterStateFault) {
					return true, err
				}

				return false, err
			},
		)

		if err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionUpdating, ResNameCluster, plan.ID.ValueString(), nil),
				err.Error(),
			)
			return
		}

		if _, err := waitDBClusterUpdated(ctx, conn, plan.ID.ValueString(), updateTimeout); err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionWaitingForUpdate, ResNameCluster, plan.ID.ValueString(), nil),
				err.Error(),
			)
			return
		}
	}

	// can only be removed.
	if !plan.GlobalClusterIdentifier.Equal(state.GlobalClusterIdentifier) {
		in := &rds.RemoveFromGlobalClusterInput{
			DbClusterIdentifier:     aws.String(state.ARN.ValueString()),
			GlobalClusterIdentifier: aws.String(state.GlobalClusterIdentifier.ValueString()),
		}

		_, err := conn.RemoveFromGlobalClusterWithContext(ctx, in)

		if err != nil && !tfawserr.ErrCodeEquals(err, rds.ErrCodeGlobalClusterNotFoundFault) && !tfawserr.ErrMessageContains(err, "InvalidParameterValue", "is not found in global cluster") {
			response.Diagnostics.AddError(
				fmt.Sprintf("removing RDS Cluster (%s) from RDS Global Cluster", plan.ID.ValueString()),
				err.Error(),
			)
			return
		}
	}

	if !plan.IamRoles.Equal(state.IamRoles) {
		o := flex.ExpandFrameworkStringValueSet(ctx, state.IamRoles)
		n := flex.ExpandFrameworkStringValueSet(ctx, plan.IamRoles)

		for _, v := range n.Difference(o) {
			if err := addIAMRoleToCluster(ctx, conn, plan.ID.ValueString(), v); err != nil {
				response.Diagnostics.AddError(
					fmt.Sprintf("adding IAM Role (%s) to RDS Cluster (%s)", v, plan.ID.ValueString()),
					err.Error(),
				)
				return
			}
		}

		for _, v := range o.Difference(n) {
			if err := removeIAMRoleFromCluster(ctx, conn, plan.ID.ValueString(), v); err != nil {
				response.Diagnostics.AddError(
					fmt.Sprintf("removing IAM Role (%s) to RDS Cluster (%s)", v, plan.ID.ValueString()),
					err.Error(),
				)
				return
			}
		}
	}

	out, err := FindDBClusterByID(ctx, conn, plan.ID.ValueString())

	if err != nil {
		response.Diagnostics.AddError(
			create.ProblemStandardMessage(names.RDS, create.ErrActionWaitingForUpdate, ResNameCluster, plan.ID.ValueString(), nil),
			err.Error(),
		)
		return
	}

	if !plan.TagsAll.Equal(state.TagsAll) {
		if err := UpdateTags(ctx, conn, plan.ARN.ValueString(), state.TagsAll, plan.TagsAll); err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionUpdating, ResNameCluster, plan.ID.String(), nil),
				err.Error(),
			)
			return
		}
		//state.Tags = plan.Tags
		//state.TagsAll = plan.TagsAll
	}

	response.Diagnostics.Append(plan.refreshFromOutput(ctx, r.Meta(), out)...)
	response.Diagnostics.Append(response.State.Set(ctx, &plan)...)
}

// Delete is called when the provider must delete the resource.
// Config values may be read from the DeleteRequest.
//
// If execution completes without error, the framework will automatically call DeleteResponse.State.RemoveResource(),
// so it can be omitted from provider logic.
func (r *resourceCluster) Delete(ctx context.Context, request resource.DeleteRequest, response *resource.DeleteResponse) {
	conn := r.Meta().RDSConn()
	var data resourceClusterData

	response.Diagnostics.Append(request.State.Get(ctx, &data)...)

	if response.Diagnostics.HasError() {
		return
	}
	deleteTimeout := r.DeleteTimeout(ctx, data.Timeouts)

	// Automatically remove from global cluster to bypass this error on deletion:
	// InvalidDBClusterStateFault: This cluster is a part of a global cluster, please remove it from globalcluster first
	if !data.GlobalClusterIdentifier.IsNull() || data.GlobalClusterIdentifier.ValueString() != "" {
		input := &rds.RemoveFromGlobalClusterInput{
			DbClusterIdentifier:     aws.String(data.ARN.ValueString()),
			GlobalClusterIdentifier: aws.String(data.GlobalClusterIdentifier.ValueString()),
		}

		tflog.Debug(ctx, "removing RDS Cluster from RDS Global Cluster", map[string]interface{}{
			"arn":                       data.ARN.ValueString(),
			"global_cluster_identifier": data.GlobalClusterIdentifier.ValueString(),
		})

		_, err := conn.RemoveFromGlobalClusterWithContext(ctx, input)

		if err != nil && !tfawserr.ErrCodeEquals(err, rds.ErrCodeGlobalClusterNotFoundFault) && !tfawserr.ErrMessageContains(err, "InvalidParameterValue", "is not found in global cluster") {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionDeleting, ResNameCluster, data.ID.String(), nil),
				err.Error(),
			)
			return
		}
	}

	input := &rds.DeleteDBClusterInput{
		DBClusterIdentifier: aws.String(data.ID.ValueString()),
		SkipFinalSnapshot:   aws.Bool(data.SkipFinalSnapshot.ValueBool()),
	}

	if !data.SkipFinalSnapshot.ValueBool() {
		input.FinalDBSnapshotIdentifier = aws.String(data.FinalSnapshotIdentifier.ValueString())
	}

	tflog.Debug(ctx, "deleting RDS Cluster", map[string]interface{}{
		"id": data.ID.ValueString(),
	})

	_, err := tfresource.RetryWhen(ctx, clusterTimeoutDelete,
		func() (interface{}, error) {
			return conn.DeleteDBClusterWithContext(ctx, input)
		},
		func(err error) (bool, error) {
			if tfawserr.ErrMessageContains(err, "InvalidParameterCombination", "disable deletion pro") {
				if (data.DeletionProtection.IsNull() || !data.DeletionProtection.ValueBool()) && data.ApplyImmediately.ValueBool() {
					_, err := tfresource.RetryWhen(ctx, deleteTimeout,
						func() (interface{}, error) {
							return conn.ModifyDBClusterWithContext(ctx, &rds.ModifyDBClusterInput{
								ApplyImmediately:    aws.Bool(true),
								DBClusterIdentifier: aws.String(data.ID.ValueString()),
								DeletionProtection:  aws.Bool(false),
							})
						},
						func(err error) (bool, error) {
							if tfawserr.ErrMessageContains(err, errCodeInvalidParameterValue, "IAM role ARN value is invalid or does not include the required permissions") {
								return true, err
							}

							if tfawserr.ErrCodeEquals(err, rds.ErrCodeInvalidDBClusterStateFault) {
								return true, err
							}

							return false, err
						},
					)

					if err != nil {
						return false, fmt.Errorf("modifying RDS Cluster (%s) DeletionProtection=false: %s", data.ID.ValueString(), err)
					}

					if _, err := waitDBClusterUpdated(ctx, conn, data.ID.ValueString(), deleteTimeout); err != nil {
						return false, fmt.Errorf("waiting for RDS Cluster (%s) update: %s", data.ID.ValueString(), err)
					}
				}

				return true, err
			}

			if tfawserr.ErrMessageContains(err, rds.ErrCodeInvalidDBClusterStateFault, "is not currently in the available state") {
				return true, err
			}

			if tfawserr.ErrMessageContains(err, rds.ErrCodeInvalidDBClusterStateFault, "cluster is a part of a global cluster") {
				return true, err
			}

			return false, err
		},
	)

	if tfawserr.ErrCodeEquals(err, rds.ErrCodeDBClusterNotFoundFault) {
		return
	}

	if err != nil {
		response.Diagnostics.AddError(
			create.ProblemStandardMessage(names.RDS, create.ErrActionDeleting, ResNameCluster, data.ID.ValueString(), nil),
			err.Error(),
		)
		return
	}

	if _, err := waitDBClusterDeleted(ctx, conn, data.ID.ValueString(), deleteTimeout); err != nil {
		response.Diagnostics.AddError(
			create.ProblemStandardMessage(names.RDS, create.ErrActionWaitingForDeletion, ResNameCluster, data.ID.ValueString(), nil),
			err.Error(),
		)
		return
	}
}

// ImportState is called when the provider must import the state of a resource instance.
// This method must return enough state so the Read method can properly refresh the full resource.
//
// If setting an attribute with the import identifier, it is recommended to use the ImportStatePassthroughID() call in this method.
func (r *resourceCluster) ImportState(ctx context.Context, request resource.ImportStateRequest, response *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), request, response)

	// Neither skip_final_snapshot nor final_snapshot_identifier can be fetched
	// from any API call, so we need to default skip_final_snapshot to true so
	// that final_snapshot_identifier is not required
	response.Diagnostics.Append(response.State.SetAttribute(ctx, path.Root("skip_final_snapshot"), true)...)
}

// ModifyPlan is called when the provider has an opportunity to modify
// the plan: once during the plan phase when Terraform is determining
// the diff that should be shown to the user for approval, and once
// during the apply phase with any unknown values from configuration
// filled in with their final values.
//
// The planned new state is represented by
// ModifyPlanResponse.Plan. It must meet the following
// constraints:
// 1. Any non-Computed attribute set in config must preserve the exact
// config value or return the corresponding attribute value from the
// prior state (ModifyPlanRequest.State).
// 2. Any attribute with a known value must not have its value changed
// in subsequent calls to ModifyPlan or Create/Read/Update.
// 3. Any attribute with an unknown value may either remain unknown
// or take on any value of the expected type.
//
// Any errors will prevent further resource-level plan modifications.
func (r *resourceCluster) ModifyPlan(ctx context.Context, request resource.ModifyPlanRequest, response *resource.ModifyPlanResponse) {
	if request.Plan.Raw.IsNull() {
		var finalSnapshotIdentifier types.String
		var skipFinalSnapshot types.Bool

		response.Diagnostics.Append(request.State.GetAttribute(ctx, path.Root("final_snapshot_identifier"), &finalSnapshotIdentifier)...)
		response.Diagnostics.Append(request.State.GetAttribute(ctx, path.Root("skip_final_snapshot"), &skipFinalSnapshot)...)

		if response.Diagnostics.HasError() {
			return
		}

		if !skipFinalSnapshot.ValueBool() && (finalSnapshotIdentifier.IsNull() || finalSnapshotIdentifier.ValueString() == "") {
			response.Diagnostics.AddAttributeError(
				path.Root("final_snapshot_identifier"),
				"Attribute cannot be empty",
				"Attribute final_snapshot_identifier cannot be empty when skip_final_snapshot is set to false. "+
					"Please apply resource with a value for final_snapshot_identifier before trying to destroy",
			)
			return
		}
	}

	var planGlobalClusterIdentifier, stateGlobalClusterIdentifier types.String

	response.Diagnostics.Append(request.Plan.GetAttribute(ctx, path.Root("global_cluster_identifier"), &planGlobalClusterIdentifier)...)
	response.Diagnostics.Append(request.State.GetAttribute(ctx, path.Root("global_cluster_identifier"), &stateGlobalClusterIdentifier)...)

	if response.Diagnostics.HasError() {
		return
	}

	if !stateGlobalClusterIdentifier.IsNull() && !planGlobalClusterIdentifier.IsNull() {
		if stateGlobalClusterIdentifier.ValueString() == "" {
			response.Diagnostics.AddAttributeError(
				path.Root("global_cluster_identifier"),
				"Cluster exists",
				"existing RDS Clusters cannot be added to an existing RDS Global Cluster",
			)
		}
	}

	if !stateGlobalClusterIdentifier.IsNull() && (planGlobalClusterIdentifier.IsNull() || planGlobalClusterIdentifier.ValueString() != "") {
		response.Diagnostics.AddAttributeError(
			path.Root("global_cluster_identifier"),
			"Cluster cannot be migrated",
			"existing RDS Clusters cannot be migrated between existing RDS Global Clusters",
		)
	}

	r.SetTagsAll(ctx, request, response)
}

func (r *resourceCluster) ConfigValidators(_ context.Context) []resource.ConfigValidator {
	return []resource.ConfigValidator{
		resourcevalidator.Conflicting(
			path.MatchRoot("cluster_identifier"),
			path.MatchRoot("cluster_identifier_prefix"),
		),
		resourcevalidator.Conflicting(
			path.MatchRoot("restore_to_point_in_time"),
			path.MatchRoot("s3_import"),
			path.MatchRoot("snapshot_identifier"),
		),
		resourcevalidator.Conflicting(
			path.MatchRoot("restore_to_point_in_time").AtListIndex(0).AtName("restore_to_time"),
			path.MatchRoot("restore_to_point_in_time").AtListIndex(0).AtName("use_latest_restorable_time"),
		),
	}
}

func (r *resourceCluster) ValidateConfig(ctx context.Context, request resource.ValidateConfigRequest, response *resource.ValidateConfigResponse) {
	var data resourceClusterData
	response.Diagnostics.Append(request.Config.Get(ctx, &data)...)

	if response.Diagnostics.HasError() {
		return
	}

	if !data.RestoreToPointInTime.IsNull() || len(data.RestoreToPointInTime.Elements()) > 0 {
		var restoreToPointInTime []restoreToPointInTime
		response.Diagnostics.Append(data.RestoreToPointInTime.ElementsAs(ctx, &restoreToPointInTime, false)...)

		if response.Diagnostics.HasError() {
			return
		}

		m := restoreToPointInTime[0]
		if m.RestoreToTime.IsNull() && m.UseLatestRestorableTime.IsNull() {
			response.Diagnostics.AddAttributeError(
				path.Root("restore_to_point_in_time"),
				"Both Attributes cannot be empty",
				"Either attribute restore_to_time or use_latest_restorable_time must be set",
			)
		}
	}

	if !data.S3Import.IsUnknown() || !data.S3Import.IsNull() || len(data.S3Import.Elements()) > 0 {
		if (data.MasterUsername.IsUnknown() || data.MasterUsername.IsNull()) || (data.MasterPassword.IsNull() || data.MasterPassword.IsUnknown()) {
			response.Diagnostics.AddAttributeError(
				path.Root("s3_import"),
				"Master Username and Password not set",
				"Attributes master_username and master_password must be set with s3_import",
			)
		}
	}
}

type resourceClusterData struct {
	AllocatedStorage                 types.Int64  `tfsdk:"allocated_storage"`
	AllowMajorVersionUpgrade         types.Bool   `tfsdk:"allow_major_version_upgrade"`
	ApplyImmediately                 types.Bool   `tfsdk:"apply_immediately"`
	ARN                              types.String `tfsdk:"arn"`
	AvailabilityZones                types.Set    `tfsdk:"availability_zones"`
	BacktrackWindow                  types.Int64  `tfsdk:"backtrack_window"`
	BackupRetentionPeriod            types.Int64  `tfsdk:"backup_retention_period"`
	ClusterIdentifier                types.String `tfsdk:"cluster_identifier"`
	ClusterIdentifierPrefix          types.String `tfsdk:"cluster_identifier_prefix"`
	ClusterMembers                   types.Set    `tfsdk:"cluster_members"`
	ClusterResourceID                types.String `tfsdk:"cluster_resource_id"`
	CopyTagsToSnapshot               types.Bool   `tfsdk:"copy_tags_to_snapshot"`
	DatabaseName                     types.String `tfsdk:"database_name"`
	DbClusterInstanceClass           types.String `tfsdk:"db_cluster_instance_class"`
	DbClusterParameterGroupName      types.String `tfsdk:"db_cluster_parameter_group_name"`
	DbInstanceParameterGroupName     types.String `tfsdk:"db_instance_parameter_group_name"`
	DbSubnetGroupName                types.String `tfsdk:"db_subnet_group_name"`
	DeletionProtection               types.Bool   `tfsdk:"deletion_protection"`
	EnableGlobalWriteForwarding      types.Bool   `tfsdk:"enable_global_write_forwarding"`
	EnableHttpEndpoint               types.Bool   `tfsdk:"enable_http_endpoint"`
	EnabledCloudwatchLogsExports     types.Set    `tfsdk:"enabled_cloudwatch_logs_exports"`
	Endpoint                         types.String `tfsdk:"endpoint"`
	Engine                           types.String `tfsdk:"engine"`
	EngineMode                       types.String `tfsdk:"engine_mode"`
	EngineVersion                    types.String `tfsdk:"engine_version"`
	EngineVersionActual              types.String `tfsdk:"engine_version_actual"`
	FinalSnapshotIdentifier          types.String `tfsdk:"final_snapshot_identifier"`
	GlobalClusterIdentifier          types.String `tfsdk:"global_cluster_identifier"`
	HostedZoneID                     types.String `tfsdk:"hosted_zone_id"`
	IamDatabaseAuthenticationEnabled types.Bool   `tfsdk:"iam_database_authentication_enabled"`
	IamRoles                         types.Set    `tfsdk:"iam_roles"`
	ID                               types.String `tfsdk:"id"`
	Iops                             types.Int64  `tfsdk:"iops"`
	KmsKeyID                         types.String `tfsdk:"kms_key_id"`
	MasterPassword                   types.String `tfsdk:"master_password"`
	MasterUsername                   types.String `tfsdk:"master_username"`
	NetworkType                      types.String `tfsdk:"network_type"`
	OptionGroupName                  types.String `tfsdk:"option_group_name"`
	Port                             types.Int64  `tfsdk:"port"`
	PreferredBackupWindow            types.String `tfsdk:"preferred_backup_window"`
	PreferredMaintenanceWindow       types.String `tfsdk:"preferred_maintenance_window"`
	ReaderEndpoint                   types.String `tfsdk:"reader_endpoint"`
	ReplicationSourceIdentifier      types.String `tfsdk:"replication_source_identifier"`
	RestoreToPointInTime             types.List   `tfsdk:"restore_to_point_in_time"`
	S3Import                         types.List   `tfsdk:"s3_import"`
	ScalingConfiguration             types.List   `tfsdk:"scaling_configuration"`
	ServerlessV2ScalingConfiguration types.List   `tfsdk:"serverlessv2_scaling_configuration"`
	SkipFinalSnapshot                types.Bool   `tfsdk:"skip_final_snapshot"`
	SnapshotIdentifier               types.String `tfsdk:"snapshot_identifier"`
	SourceRegion                     types.String `tfsdk:"source_region"`
	StorageEncrypted                 types.Bool   `tfsdk:"storage_encrypted"`
	StorageType                      types.String `tfsdk:"storage_type"`
	Tags                             types.Map    `tfsdk:"tags"`
	TagsAll                          types.Map    `tfsdk:"tags_all"`
	VpcSecurityGroupIds              types.Set    `tfsdk:"vpc_security_group_ids"`

	Timeouts timeouts.Value `tfsdk:"timeouts"`
}

type restoreToPointInTime struct {
	RestoreToTime           types.String `tfsdk:"restore_to_time"`
	RestoreType             types.String `tfsdk:"restore_type"`
	SourceClusterIdentifier types.String `tfsdk:"source_cluster_identifier"`
	UseLatestRestorableTime types.Bool   `tfsdk:"use_latest_restorable_time"`
}

type s3Import struct {
	BucketName          types.String `tfsdk:"bucket_name"`
	BucketPrefix        types.String `tfsdk:"bucket_prefix"`
	IngestionRole       types.String `tfsdk:"ingestion_role"`
	SourceEngine        types.String `tfsdk:"source_engine"`
	SourceEngineVersion types.String `tfsdk:"source_engine_version"`
}

type scalingConfiguration struct {
	AutoPause             types.Bool   `tfsdk:"auto_pause"`
	MaxCapacity           types.Int64  `tfsdk:"max_capacity"`
	MinCapacity           types.Int64  `tfsdk:"min_capacity"`
	SecondsUntilAutoPause types.Int64  `tfsdk:"seconds_until_auto_pause"`
	TimeoutAction         types.String `tfsdk:"timeout_action"`
}

type serverlessV2ScalingConfiguration struct {
	MaxCapacity types.Float64 `tfsdk:"max_capacity"`
	MinCapacity types.Float64 `tfsdk:"min_capacity"`
}

var (
	//restoreToPointInTimeTypes = map[string]attr.Type{
	//	"restore_to_time":            types.StringType,
	//	"restore_type":               types.StringType,
	//	"source_cluster_identifier":  types.StringType,
	//	"use_latest_restorable_time": types.BoolType,
	//}
	//
	//s3ImportAttrTypes = map[string]attr.Type{
	//	"bucket_name":           types.StringType,
	//	"bucket_prefix":         types.StringType,
	//	"ingestion_role":        types.StringType,
	//	"source_engine":         types.StringType,
	//	"source_engine_version": types.StringType,
	//}

	scalingConfigurationAttrTypes = map[string]attr.Type{
		"auto_pause":               types.BoolType,
		"max_capacity":             types.Int64Type,
		"min_capacity":             types.Int64Type,
		"seconds_until_auto_pause": types.Int64Type,
		"timeout_action":           types.StringType,
	}

	serverlessV2ScalingConfigurationAttrTypes = map[string]attr.Type{
		"max_capacity": types.Float64Type,
		"min_capacity": types.Float64Type,
	}
)

func (r *resourceClusterData) refreshFromOutput(ctx context.Context, meta *conns.AWSClient, out *rds.DBCluster) diag.Diagnostics {
	var diags diag.Diagnostics
	defaultTagsConfig := meta.DefaultTagsConfig
	ignoreTagsConfig := meta.IgnoreTagsConfig

	r.AllocatedStorage = flex.Int64ToFrameworkLegacy(ctx, out.AllocatedStorage)
	r.ARN = flex.StringToFrameworkLegacy(ctx, out.DBClusterArn)
	r.AvailabilityZones = flex.FlattenFrameworkStringSetLegacy(ctx, out.AvailabilityZones)
	r.BacktrackWindow = flex.Int64ToFrameworkLegacy(ctx, out.BacktrackWindow)
	r.BackupRetentionPeriod = flex.Int64ToFrameworkLegacy(ctx, out.BackupRetentionPeriod)
	r.BackupRetentionPeriod = flex.Int64ToFrameworkLegacy(ctx, out.BackupRetentionPeriod)
	r.ClusterIdentifier = flex.StringToFrameworkLegacy(ctx, out.DBClusterIdentifier)

	var clusterMembers []string
	for _, v := range out.DBClusterMembers {
		clusterMembers = append(clusterMembers, aws.StringValue(v.DBInstanceIdentifier))
	}
	r.ClusterMembers = flex.FlattenFrameworkStringValueSetLegacy(ctx, clusterMembers)
	r.ClusterResourceID = flex.StringToFrameworkLegacy(ctx, out.DbClusterResourceId)
	r.CopyTagsToSnapshot = flex.BoolToFrameworkLegacy(ctx, out.CopyTagsToSnapshot)

	// Only set the DatabaseName if it is not nil. There is a known API bug where
	// RDS accepts a DatabaseName but does not return it, causing a perpetual
	// diff.
	//	See https://github.com/hashicorp/terraform/issues/4671 for backstory
	if out.DatabaseName != nil {
		r.DatabaseName = flex.StringToFrameworkLegacy(ctx, out.DatabaseName)
	}
	r.DbClusterInstanceClass = flex.StringToFrameworkLegacy(ctx, out.DBClusterInstanceClass)
	r.DbClusterParameterGroupName = flex.StringToFrameworkLegacy(ctx, out.DBClusterParameterGroup)
	r.DbSubnetGroupName = flex.StringToFrameworkLegacy(ctx, out.DBSubnetGroup)
	r.DeletionProtection = flex.BoolToFramework(ctx, out.DeletionProtection)
	r.EnabledCloudwatchLogsExports = flex.FlattenFrameworkStringValueSet(ctx, aws.StringValueSlice(out.EnabledCloudwatchLogsExports))
	r.EnableHttpEndpoint = flex.BoolToFrameworkLegacy(ctx, out.HttpEndpointEnabled)
	r.Endpoint = flex.StringToFrameworkLegacy(ctx, out.Endpoint)
	r.Engine = flex.StringToFrameworkLegacy(ctx, out.Engine)
	r.EngineMode = flex.StringToFrameworkLegacy(ctx, out.EngineMode)
	r.setResourceDataEngineVersionFromCluster(ctx, out)
	r.HostedZoneID = flex.StringToFrameworkLegacy(ctx, out.HostedZoneId)
	r.IamDatabaseAuthenticationEnabled = flex.BoolToFrameworkLegacy(ctx, out.IAMDatabaseAuthenticationEnabled)

	var iamRoleARNs []string
	for _, v := range out.AssociatedRoles {
		iamRoleARNs = append(iamRoleARNs, aws.StringValue(v.RoleArn))
	}
	r.IamRoles = flex.FlattenFrameworkStringValueSetLegacy(ctx, iamRoleARNs)
	r.Iops = flex.Int64ToFrameworkLegacy(ctx, out.Iops)
	r.KmsKeyID = flex.StringToFrameworkLegacy(ctx, out.KmsKeyId)
	r.MasterUsername = flex.StringToFrameworkLegacy(ctx, out.MasterUsername)
	r.NetworkType = flex.StringToFrameworkLegacy(ctx, out.NetworkType)
	r.Port = flex.Int64ToFrameworkLegacy(ctx, out.Port)
	r.PreferredBackupWindow = flex.StringToFrameworkLegacy(ctx, out.PreferredBackupWindow)

	pmw := strings.ToLower(aws.StringValue(out.PreferredMaintenanceWindow))
	r.PreferredMaintenanceWindow = flex.StringValueToFrameworkLegacy(ctx, pmw)
	r.ReaderEndpoint = flex.StringToFrameworkLegacy(ctx, out.ReaderEndpoint)
	r.ReplicationSourceIdentifier = flex.StringToFrameworkLegacy(ctx, out.ReplicationSourceIdentifier)
	r.ScalingConfiguration = flattenScalingConfigurationFramework(ctx, out.ScalingConfigurationInfo)
	r.ServerlessV2ScalingConfiguration = flattenServerlessV2ScalingConfigurationFramework(ctx, out.ServerlessV2ScalingConfiguration)
	r.StorageEncrypted = flex.BoolToFramework(ctx, out.StorageEncrypted)
	r.StorageType = flex.StringToFrameworkLegacy(ctx, out.StorageType)

	var securityGroupIDs []string
	for _, v := range out.VpcSecurityGroups {
		securityGroupIDs = append(securityGroupIDs, aws.StringValue(v.VpcSecurityGroupId))
	}
	r.VpcSecurityGroupIds = flex.FlattenFrameworkStringValueSetLegacy(ctx, securityGroupIDs)

	tags, err := ListTags(ctx, meta.RDSConn(), aws.StringValue(out.DBClusterArn))
	if err != nil {
		diags.AddError(
			"Cannot list tags for RDS Cluster",
			err.Error(),
		)
	}

	tags = tags.IgnoreAWS().IgnoreConfig(ignoreTagsConfig)
	if tags := tags.RemoveDefaultConfig(defaultTagsConfig).Map(); len(tags) == 0 {
		r.Tags = tftags.Null
	} else {
		r.Tags = flex.FlattenFrameworkStringValueMapLegacy(ctx, tags)
	}
	r.TagsAll = flex.FlattenFrameworkStringValueMapLegacy(ctx, tags.Map())

	return diags
}

func (r *resourceClusterData) setResourceDataEngineVersionFromCluster(ctx context.Context, out *rds.DBCluster) {
	oldVersion := r.EngineVersion.ValueString()
	newVersion := aws.StringValue(out.EngineVersion)
	newVersionSubstr := newVersion

	if len(newVersion) > len(oldVersion) {
		newVersionSubstr = string([]byte(newVersion)[0 : len(oldVersion)+1])
	}

	if oldVersion != newVersion && string(append([]byte(oldVersion), []byte(".")...)) != newVersionSubstr {
		r.EngineVersion = flex.StringValueToFrameworkLegacy(ctx, newVersion)
	}

	r.EngineVersionActual = flex.StringValueToFrameworkLegacy(ctx, newVersion)
}
