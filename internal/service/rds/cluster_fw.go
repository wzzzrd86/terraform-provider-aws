// Code generated by tools/tfsdk2fw/main.go. Manual editing is required.

package rds

import (
	"context"
	"regexp"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/rds"
	"github.com/hashicorp/aws-sdk-go-base/v2/awsv1shim/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	sdkresource "github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/float64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/resourcevalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwboolplanmodifier "github.com/hashicorp/terraform-provider-aws/internal/framework/boolplanmodifier"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"

	fwint64planmodifier "github.com/hashicorp/terraform-provider-aws/internal/framework/int64planmodifier"
	fwstringplanmodifier "github.com/hashicorp/terraform-provider-aws/internal/framework/stringplanmodifier"
)

func init() {
	_sp.registerFrameworkResourceFactory(newResourceCluster)
}

// newResourceCluster instantiates a new Resource for the aws_rds_cluster resource.
func newResourceCluster(context.Context) (resource.ResourceWithConfigure, error) {
	r := &resourceCluster{}
	r.SetMigratedFromPluginSDK(true)
	r.SetDefaultCreateTimeout(7200000000000 * time.Nanosecond) // TODO Convert to more human-friendly duration.
	r.SetDefaultUpdateTimeout(7200000000000 * time.Nanosecond) // TODO Convert to more human-friendly duration.
	r.SetDefaultDeleteTimeout(7200000000000 * time.Nanosecond) // TODO Convert to more human-friendly duration.

	return r, nil
}

const (
	ResNameCluster = "Cluster"
)

type resourceCluster struct {
	framework.ResourceWithConfigure
	framework.WithTimeouts
}

// Metadata should return the full name of the resource, such as
// examplecloud_thing.
func (r *resourceCluster) Metadata(_ context.Context, request resource.MetadataRequest, response *resource.MetadataResponse) {
	response.TypeName = "aws_rds_cluster"
}

// Schema returns the schema for this resource.
func (r *resourceCluster) Schema(ctx context.Context, request resource.SchemaRequest, response *resource.SchemaResponse) {
	s := schema.Schema{
		Attributes: map[string]schema.Attribute{
			"allocated_storage": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"allow_major_version_upgrade": schema.BoolAttribute{
				Optional: true,
			},
			"apply_immediately": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"arn": schema.StringAttribute{
				CustomType: fwtypes.ARNType,
				Computed: true,
			},
			"availability_zones": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.RequiresReplace(),
				},
			},
			"backtrack_window": schema.Int64Attribute{
				Optional: true,
				Validators: []validator.Int64{
					int64validator.Between(0, 259200),
				},
			},
			"backup_retention_period": schema.Int64Attribute{
				Optional: true,
				PlanModifiers: []planmodifier.Int64{
					fwint64planmodifier.DefaultValue(1),
				},
				Validators: []validator.Int64{
					int64validator.AtMost(35),
				},
			},
			"cluster_identifier": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile(`^[0-9a-z-]+$`), "only lowercase alphanumeric characters and hyphens allowed"),
					stringvalidator.RegexMatches(regexp.MustCompile(`^[a-z]`), "first character must be a letter"),
					// TODO finish validators
				},
			},
			"cluster_identifier_prefix": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				// TODO Validate,
			},
			"cluster_members": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"cluster_resource_id": schema.StringAttribute{
				Computed: true,
			},
			"copy_tags_to_snapshot": schema.BoolAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.Bool{
					fwboolplanmodifier.DefaultValue(false),
				},
			},
			"database_name": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"db_cluster_instance_class": schema.StringAttribute{
				Optional: true,
			},
			"db_cluster_parameter_group_name": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"db_instance_parameter_group_name": schema.StringAttribute{
				Optional: true,
			},
			"db_subnet_group_name": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"deletion_protection": schema.BoolAttribute{
				Optional: true,
			},
			"enable_global_write_forwarding": schema.BoolAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.Bool{
					fwboolplanmodifier.DefaultValue(false),
				},
			},
			"enable_http_endpoint": schema.BoolAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.Bool{
					fwboolplanmodifier.DefaultValue(false),
				},
			},
			"enabled_cloudwatch_logs_exports": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Validators: []validator.Set{
					setvalidator.ValueStringsAre(stringvalidator.OneOf(ClusterExportableLogType_Values()...)),
				},
			},
			"endpoint": schema.StringAttribute{
				Computed: true,
			},
			"engine": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					fwstringplanmodifier.DefaultValue(ClusterEngineAurora),
				},
				Validators: []validator.String{
					stringvalidator.OneOf(ClusterEngine_Values()...),
				},
			},
			"engine_mode": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					fwstringplanmodifier.DefaultValue(EngineModeProvisioned),
				},
				Validators: []validator.String{
					stringvalidator.OneOf(EngineMode_Values()...),
				},
			},
			"engine_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"engine_version_actual": schema.StringAttribute{
				Computed: true,
			},
			"final_snapshot_identifier": schema.StringAttribute{
				Optional: true,
				// TODO Validate,
			},
			"global_cluster_identifier": schema.StringAttribute{
				Optional: true,
			},
			"hosted_zone_id": schema.StringAttribute{
				Computed: true,
			},
			"iam_database_authentication_enabled": schema.BoolAttribute{
				Optional: true,
			},
			"iam_roles": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"id": framework.IDAttribute(),
			"iops": schema.Int64Attribute{
				Optional: true,
			},
			"kms_key_id": schema.StringAttribute{
				CustomType: fwtypes.ARNType,
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"master_password": schema.StringAttribute{
				Optional:  true,
				Sensitive: true,
			},
			"master_username": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"network_type": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(NetworkType_Values()...),
				},
			},
			"option_group_name": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"port": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"preferred_backup_window": schema.StringAttribute{
				Optional: true,
				Computed: true,
				// TODO Validate,
			},
			"preferred_maintenance_window": schema.StringAttribute{
				Optional: true,
				Computed: true,
				// TODO Validate,
			},
			"reader_endpoint": schema.StringAttribute{
				Computed: true,
			},
			"replication_source_identifier": schema.StringAttribute{
				Optional: true,
			},
			"skip_final_snapshot": schema.BoolAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.Bool{
					fwboolplanmodifier.DefaultValue(false),
				},
			},
			"snapshot_identifier": schema.StringAttribute{
				Optional: true,
			},
			"source_region": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"storage_encrypted": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
			},
			"storage_type": schema.StringAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"tags":     tftags.TagsAttribute(),
			"tags_all": tftags.TagsAttributeComputedOnly(),
			"vpc_security_group_ids": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
		},
		Blocks: map[string]schema.Block{
			"restore_to_point_in_time": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"restore_to_time": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
							// TODO Validate,
						},
						"restore_type": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf(RestoreType_Values()...),
							},
						},
						"source_cluster_identifier": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
							// TODO Validate,
						},
						"use_latest_restorable_time": schema.BoolAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.Bool{
								boolplanmodifier.RequiresReplace(),
							},
						},
					},
				},
				Validators: []validator.List{
					listvalidator.SizeAtMost(1),
				},
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},
			},
			"s3_import": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"bucket_name": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"bucket_prefix": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"ingestion_role": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"source_engine": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"source_engine_version": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
					},
				},
				Validators: []validator.List{
					listvalidator.SizeAtMost(1),
				},
			},
			"scaling_configuration": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"auto_pause": schema.BoolAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.Bool{
								fwboolplanmodifier.DefaultValue(true),
							},
						},
						"max_capacity": schema.Int64Attribute{
							Optional: true,
							PlanModifiers: []planmodifier.Int64{
								fwint64planmodifier.DefaultValue(clusterScalingConfiguration_DefaultMaxCapacity),
							},
						},
						"min_capacity": schema.Int64Attribute{
							Optional: true,
							PlanModifiers: []planmodifier.Int64{
								fwint64planmodifier.DefaultValue(clusterScalingConfiguration_DefaultMinCapacity),
							},
						},
						"seconds_until_auto_pause": schema.Int64Attribute{
							Optional: true,
							PlanModifiers: []planmodifier.Int64{
								fwint64planmodifier.DefaultValue(300),
							},
							Validators: []validator.Int64{
								int64validator.Between(300, 86400),
							},
						},
						"timeout_action": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								fwstringplanmodifier.DefaultValue(TimeoutActionRollbackCapacityChange),
							},
							Validators: []validator.String{
								stringvalidator.OneOf(TimeoutAction_Values()...),
							},
						},
					},
				},
				Validators: []validator.List{
					listvalidator.SizeAtMost(1),
				},
			},
			"serverlessv2_scaling_configuration": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"max_capacity": schema.Float64Attribute{
							Required: true,
							Validators: []validator.Float64{
								float64validator.Between(0.5, 128),
							},
						},
						"min_capacity": schema.Float64Attribute{
							Required: true,
							Validators: []validator.Float64{
								float64validator.Between(0.5, 128),
							},
						},
					},
				},
				Validators: []validator.List{
					listvalidator.SizeAtMost(1),
				},
			},
		},
	}

	if s.Blocks == nil {
		s.Blocks = make(map[string]schema.Block)
	}
	s.Blocks["timeouts"] = timeouts.Block(ctx, timeouts.Opts{
		Create: true,
		Update: true,
		Delete: true,
	})

	response.Schema = s
}

// Create is called when the provider must create a new resource.
// Config and planned state values should be read from the CreateRequest and new state values set on the CreateResponse.
func (r *resourceCluster) Create(ctx context.Context, request resource.CreateRequest, response *resource.CreateResponse) {
	var data resourceClusterData
	conn := r.Meta().RDSConn()

	defaultTagsConfig := r.Meta().DefaultTagsConfig
	ignoreTagsConfig := r.Meta().IgnoreTagsConfig
	tags := defaultTagsConfig.MergeTags(tftags.New(data.Tags))
	data.TagsAll = flex.FlattenFrameworkStringValueMapLegacy(ctx, tags.IgnoreAWS().IgnoreConfig(ignoreTagsConfig).Map()

	response.Diagnostics.Append(request.Plan.Get(ctx, &data)...)

	if response.Diagnostics.HasError() {
		return
	}
	createTimeout := r.CreateTimeout(ctx, data.Timeouts)

	var requiresModifyDbCluster bool
	modifyDbClusterInput := &rds.ModifyDBClusterInput{
		ApplyImmediately: aws.Bool(true),
	}

	var identifier string
	if !data.ClusterIdentifier.IsUnknown() && !data.ClusterIdentifier.IsNull() {
		identifier = data.ClusterIdentifier.ValueString()
	} else if !data.ClusterIdentifierPrefix.IsUnknown() && !data.ClusterIdentifierPrefix.IsNull() {
		identifier = sdkresource.PrefixedUniqueId(data.ClusterIdentifierPrefix.ValueString())
	} else {
		identifier = sdkresource.PrefixedUniqueId("tf-")
	}

	if !data.SnapshotIdentifier.IsUnknown() && !data.FinalSnapshotIdentifier.IsNull() {
		input := &rds.RestoreDBClusterFromSnapshotInput{
			CopyTagsToSnapshot: aws.Bool(data.CopyTagsToSnapshot.ValueBool()),
			DBClusterIdentifier: aws.String(identifier),
			DeletionProtection: aws.Bool(data.DeletionProtection.ValueBool()),
			Engine: aws.String(data.Engine.ValueString()),
			EngineMode: aws.String(data.EngineMode.ValueString()),
			Tags: Tags(tags.IgnoreAWS()),
		}

		if !data.AvailabilityZones.IsUnknown() && !data.AvailabilityZones.IsNull() {
			input.AvailabilityZones = flex.ExpandFrameworkStringSet(ctx, data.AvailabilityZones)
		}

		if !data.BacktrackWindow.IsNull() {
			input.BacktrackWindow = aws.Int64(data.BacktrackWindow.ValueInt64())
		}

		if !data.BackupRetentionPeriod.IsNull() {
			modifyDbClusterInput.BackupRetentionPeriod = aws.Int64(data.BackupRetentionPeriod.ValueInt64())
			requiresModifyDbCluster = true
		}

		if !data.DatabaseName.IsUnknown() && !data.DatabaseName.IsNull() {
			input.DatabaseName = aws.String(data.DatabaseName.ValueString())
		}

		if !data.DbClusterParameterGroupName.IsUnknown() && !data.DbInstanceParameterGroupName.IsNull() {
			input.DBClusterParameterGroupName = aws.String(data.DbInstanceParameterGroupName.ValueString())
		}

		if !data.DbSubnetGroupName.IsUnknown() && !data.DbSubnetGroupName.IsNull() {
			input.DBSubnetGroupName = aws.String(data.DbSubnetGroupName.ValueString())
		}

		if !data.EnabledCloudwatchLogsExports.IsNull() {
			input.EnableCloudwatchLogsExports = flex.ExpandFrameworkStringSet(ctx, data.EnabledCloudwatchLogsExports)
		}

		if !data.EngineVersion.IsUnknown() && !data.EngineVersion.IsNull() {
			input.EngineVersion = aws.String(data.EngineVersion.ValueString())
		}

		if !data.KmsKeyID.IsUnknown() && !data.KmsKeyID.IsNull() {
			input.KmsKeyId = aws.String(data.KmsKeyID.String())
		}

		if !data.MasterPassword.IsNull() {
			modifyDbClusterInput.MasterUserPassword = aws.String(data.MasterPassword.ValueString())
			requiresModifyDbCluster = true
		}

		if !data.NetworkType.IsUnknown() && !data.NetworkType.IsNull() {
			input.NetworkType = aws.String(data.NetworkType.ValueString())
		}

		if !data.OptionGroupName.IsUnknown() && !data.OptionGroupName.IsNull() {
			input.OptionGroupName = aws.String(data.OptionGroupName.ValueString())
		}

		if !data.Port.IsUnknown() && !data.Port.IsNull() {
			input.Port = aws.Int64(data.Port.ValueInt64())
		}

		if !data.PreferredBackupWindow.IsUnknown() && !data.PreferredBackupWindow.IsNull() {
			modifyDbClusterInput.PreferredBackupWindow = aws.String(data.PreferredBackupWindow.ValueString())
			requiresModifyDbCluster = true
		}

		if !data.PreferredMaintenanceWindow.IsUnknown() && !data.PreferredMaintenanceWindow.IsNull() {
			modifyDbClusterInput.PreferredMaintenanceWindow = aws.String(data.PreferredMaintenanceWindow.ValueString())
			requiresModifyDbCluster = true
		}

		var scalingConfiguration []scalingConfiguration
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &scalingConfiguration, false)...)
		if response.Diagnostics.HasError() {
			return
		}
		input.ScalingConfiguration = expandScalingConfigurationFramework(scalingConfiguration)

		var serverlessV2ScalingConfiguration []serverlessV2ScalingConfiguration
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &serverlessV2ScalingConfiguration, false)...)
		if response.Diagnostics.HasError() {
			return
		}
		input.ServerlessV2ScalingConfiguration = expandServerlessV2ScalingConfigurationFramework(serverlessV2ScalingConfiguration)

		if !data.VpcSecurityGroupIds.IsUnknown() && !data.VpcSecurityGroupIds.IsNull() {
			input.VpcSecurityGroupIds = flex.ExpandFrameworkStringSet(ctx, data.VpcSecurityGroupIds)
		}

		_, err := tfresource.RetryWhenAWSErrMessageContains(ctx, propagationTimeout,
			func() (interface{}, error) {
				return conn.RestoreDBClusterFromSnapshotWithContext(ctx, input)
			},
			errCodeInvalidParameterValue, "IAM role ARN value is invalid or does not include the required permissions")

		if err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionCreating, ResNameCluster, identifier, nil),
				err.Error(),
				)
			return
		}
	} else if !data.S3Import.IsNull() && len(data.S3Import.Elements()) > 0 {
		var s3Import []s3Import
		response.Diagnostics.Append(data.ScalingConfiguration.ElementsAs(ctx, &s3Import, false)...)
		if response.Diagnostics.HasError() {
			return
		}

		importValues := s3Import[0]
		input := &rds.RestoreDBClusterFromS3Input{
			CopyTagsToSnapshot: aws.Bool(data.CopyTagsToSnapshot.ValueBool()),
			DBClusterIdentifier: aws.String(identifier),
			DeletionProtection:  aws.Bool(data.DeletionProtection.ValueBool()),
			Engine: aws.String(data.Engine.ValueString()),
			MasterUsername: aws.String(data.MasterUsername.ValueString()),
			MasterUserPassword: aws.String(data.MasterPassword.ValueString()),
			S3BucketName: aws.String(importValues.BucketName.ValueString()),
			S3IngestionRoleArn: aws.String(importValues.IngestionRole.ValueString()),
			S3Prefix: aws.String(importValues.BucketPrefix.ValueString()),
			SourceEngine: aws.String(importValues.SourceEngine.ValueString()),
			SourceEngineVersion: aws.String(importValues.SourceEngineVersion.ValueString()),
			Tags: Tags(tags.IgnoreAWS()),
		}

		if !data.AvailabilityZones.IsUnknown() && !data.AvailabilityZones.IsNull() {
			input.AvailabilityZones = flex.ExpandFrameworkStringSet(ctx, data.AvailabilityZones)
		}

		if !data.BacktrackWindow.IsNull() {
			input.BacktrackWindow = aws.Int64(data.BacktrackWindow.ValueInt64())
		}

		if !data.BackupRetentionPeriod.IsNull() {
			input.BackupRetentionPeriod = aws.Int64(data.BackupRetentionPeriod.ValueInt64())
		}

		if !data.DatabaseName.IsUnknown() && !data.DatabaseName.IsNull() {
			input.DatabaseName = aws.String(data.DatabaseName.ValueString())
		}

		if !data.DbClusterParameterGroupName.IsUnknown() && !data.DbInstanceParameterGroupName.IsNull() {
			input.DBClusterParameterGroupName = aws.String(data.DbInstanceParameterGroupName.ValueString())
		}

		if !data.DbSubnetGroupName.IsUnknown() && !data.DbSubnetGroupName.IsNull() {
			input.DBSubnetGroupName = aws.String(data.DbSubnetGroupName.ValueString())
		}

		if !data.EnabledCloudwatchLogsExports.IsNull() {
			input.EnableCloudwatchLogsExports = flex.ExpandFrameworkStringSet(ctx, data.EnabledCloudwatchLogsExports)
		}

		if !data.EngineVersion.IsUnknown() && !data.EngineVersion.IsNull() {
			input.EngineVersion = aws.String(data.EngineVersion.ValueString())
		}

		if !data.IamDatabaseAuthenticationEnabled.IsNull() {
			input.EnableIAMDatabaseAuthentication = aws.Bool(data.IamDatabaseAuthenticationEnabled.ValueBool())
		}

		if !data.KmsKeyID.IsUnknown() && !data.KmsKeyID.IsNull() {
			input.KmsKeyId = aws.String(data.KmsKeyID.String())
		}

		if !data.NetworkType.IsUnknown() && !data.NetworkType.IsNull() {
			input.NetworkType = aws.String(data.NetworkType.ValueString())
		}

		if !data.Port.IsUnknown() && !data.Port.IsNull() {
			input.Port = aws.Int64(data.Port.ValueInt64())
		}

		if !data.PreferredBackupWindow.IsUnknown() && !data.PreferredBackupWindow.IsNull() {
			input.PreferredBackupWindow = aws.String(data.PreferredBackupWindow.ValueString())
		}

		if !data.PreferredMaintenanceWindow.IsUnknown() && !data.PreferredMaintenanceWindow.IsNull() {
			input.PreferredMaintenanceWindow = aws.String(data.PreferredMaintenanceWindow.ValueString())
		}

		if !data.StorageEncrypted.IsUnknown() && !data.StorageEncrypted.IsNull() {
			input.StorageEncrypted = aws.Bool(data.StorageEncrypted.ValueBool())
		}

		if !data.VpcSecurityGroupIds.IsUnknown() && !data.VpcSecurityGroupIds.IsNull() {
			input.VpcSecurityGroupIds = flex.ExpandFrameworkStringSet(ctx, data.VpcSecurityGroupIds)
		}

		_, err := tfresource.RetryWhen(ctx, propagationTimeout,
			func() (interface{}, error) {
				return conn.RestoreDBClusterFromS3WithContext(ctx, input)
			},
			func(err error) (bool, error) {
				// InvalidParameterValue: Files from the specified Amazon S3 bucket cannot be downloaded.
				// Make sure that you have created an AWS Identity and Access Management (IAM) role that lets Amazon RDS access Amazon S3 for you.
				if tfawserr.ErrMessageContains(err, errCodeInvalidParameterValue, "Files from the specified Amazon S3 bucket cannot be downloaded") {
					return true, err
				}

				if tfawserr.ErrMessageContains(err, errCodeInvalidParameterValue, "S3_SNAPSHOT_INGESTION") {
					return true, err
				}

				if tfawserr.ErrMessageContains(err, errCodeInvalidParameterValue, "S3 bucket cannot be found") {
					return true, err
				}

				return false, err
			},
		)

		if err != nil {
			response.Diagnostics.AddError(
				create.ProblemStandardMessage(names.RDS, create.ErrActionCreating, ResNameCluster, identifier, nil),
				err.Error(),
			)
			return
		}
	}



	data.ID = types.StringValue("TODO")

	response.Diagnostics.Append(response.State.Set(ctx, &data)...)
}

// Read is called when the provider must read resource values in order to update state.
// Planned state values should be read from the ReadRequest and new state values set on the ReadResponse.
func (r *resourceCluster) Read(ctx context.Context, request resource.ReadRequest, response *resource.ReadResponse) {
	var data resourceClusterData

	response.Diagnostics.Append(request.State.Get(ctx, &data)...)

	if response.Diagnostics.HasError() {
		return
	}

	response.Diagnostics.Append(response.State.Set(ctx, &data)...)
}

// Update is called to update the state of the resource.
// Config, planned state, and prior state values should be read from the UpdateRequest and new state values set on the UpdateResponse.
func (r *resourceCluster) Update(ctx context.Context, request resource.UpdateRequest, response *resource.UpdateResponse) {
	var old, new resourceClusterData

	response.Diagnostics.Append(request.State.Get(ctx, &old)...)

	if response.Diagnostics.HasError() {
		return
	}

	response.Diagnostics.Append(request.Plan.Get(ctx, &new)...)

	if response.Diagnostics.HasError() {
		return
	}
	updateTimeout := r.UpdateTimeout(ctx, new.Timeouts)

	response.Diagnostics.Append(response.State.Set(ctx, &new)...)
}

// Delete is called when the provider must delete the resource.
// Config values may be read from the DeleteRequest.
//
// If execution completes without error, the framework will automatically call DeleteResponse.State.RemoveResource(),
// so it can be omitted from provider logic.
func (r *resourceCluster) Delete(ctx context.Context, request resource.DeleteRequest, response *resource.DeleteResponse) {
	var data resourceClusterData

	response.Diagnostics.Append(request.State.Get(ctx, &data)...)

	if response.Diagnostics.HasError() {
		return
	}
	deleteTimeout := r.DeleteTimeout(ctx, data.Timeouts)

	tflog.Debug(ctx, "deleting TODO", map[string]interface{}{
		"id": data.ID.ValueString(),
	})
}

// ImportState is called when the provider must import the state of a resource instance.
// This method must return enough state so the Read method can properly refresh the full resource.
//
// If setting an attribute with the import identifier, it is recommended to use the ImportStatePassthroughID() call in this method.
func (r *resourceCluster) ImportState(ctx context.Context, request resource.ImportStateRequest, response *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), request, response)
}

// ModifyPlan is called when the provider has an opportunity to modify
// the plan: once during the plan phase when Terraform is determining
// the diff that should be shown to the user for approval, and once
// during the apply phase with any unknown values from configuration
// filled in with their final values.
//
// The planned new state is represented by
// ModifyPlanResponse.Plan. It must meet the following
// constraints:
// 1. Any non-Computed attribute set in config must preserve the exact
// config value or return the corresponding attribute value from the
// prior state (ModifyPlanRequest.State).
// 2. Any attribute with a known value must not have its value changed
// in subsequent calls to ModifyPlan or Create/Read/Update.
// 3. Any attribute with an unknown value may either remain unknown
// or take on any value of the expected type.
//
// Any errors will prevent further resource-level plan modifications.
func (r *resourceCluster) ModifyPlan(ctx context.Context, request resource.ModifyPlanRequest, response *resource.ModifyPlanResponse) {
	r.SetTagsAll(ctx, request, response)
}

func (r *resourceCluster) ConfigValidators(ctx context.Context) []resource.ConfigValidator {
	return []resource.ConfigValidator{
		resourcevalidator.Conflicting(
			path.MatchRoot("cluster_identifier"),
			path.MatchRoot("cluster_identifier_prefix"),
		),
		resourcevalidator.Conflicting(
			path.MatchRoot("restore_to_point_in_time"),
			path.MatchRoot("s3_import"),
			path.MatchRoot("snapshot_identifier"),
		),
		resourcevalidator.Conflicting(
			path.MatchRoot("restore_to_point_in_time").AtListIndex(0).AtName("restore_to_time"),
			path.MatchRoot("restore_to_point_in_time").AtListIndex(0).AtName("use_latest_restorable_time"),
		),
		resourcevalidator.RequiredTogether(
			path.MatchRoot("s3_import"),
			path.MatchRoot("master_password"),
			path.MatchRoot("master_username"),
			),
	}
}

type resourceClusterData struct {
	AllocatedStorage                 types.Int64  `tfsdk:"allocated_storage"`
	AllowMajorVersionUpgrade         types.Bool   `tfsdk:"allow_major_version_upgrade"`
	ApplyImmediately                 types.Bool   `tfsdk:"apply_immediately"`
	ARN                              types.String `tfsdk:"arn"`
	AvailabilityZones                types.Set    `tfsdk:"availability_zones"`
	BacktrackWindow                  types.Int64  `tfsdk:"backtrack_window"`
	BackupRetentionPeriod            types.Int64  `tfsdk:"backup_retention_period"`
	ClusterIdentifier                types.String `tfsdk:"cluster_identifier"`
	ClusterIdentifierPrefix          types.String `tfsdk:"cluster_identifier_prefix"`
	ClusterMembers                   types.Set    `tfsdk:"cluster_members"`
	ClusterResourceID                types.String `tfsdk:"cluster_resource_id"`
	CopyTagsToSnapshot               types.Bool   `tfsdk:"copy_tags_to_snapshot"`
	DatabaseName                     types.String `tfsdk:"database_name"`
	DbClusterInstanceClass           types.String `tfsdk:"db_cluster_instance_class"`
	DbClusterParameterGroupName      types.String `tfsdk:"db_cluster_parameter_group_name"`
	DbInstanceParameterGroupName     types.String `tfsdk:"db_instance_parameter_group_name"`
	DbSubnetGroupName                types.String `tfsdk:"db_subnet_group_name"`
	DeletionProtection               types.Bool   `tfsdk:"deletion_protection"`
	EnableGlobalWriteForwarding      types.Bool   `tfsdk:"enable_global_write_forwarding"`
	EnableHttpEndpoint               types.Bool   `tfsdk:"enable_http_endpoint"`
	EnabledCloudwatchLogsExports     types.Set    `tfsdk:"enabled_cloudwatch_logs_exports"`
	Endpoint                         types.String `tfsdk:"endpoint"`
	Engine                           types.String `tfsdk:"engine"`
	EngineMode                       types.String `tfsdk:"engine_mode"`
	EngineVersion                    types.String `tfsdk:"engine_version"`
	EngineVersionActual              types.String `tfsdk:"engine_version_actual"`
	FinalSnapshotIdentifier          types.String `tfsdk:"final_snapshot_identifier"`
	GlobalClusterIdentifier          types.String `tfsdk:"global_cluster_identifier"`
	HostedZoneID                     types.String `tfsdk:"hosted_zone_id"`
	IamDatabaseAuthenticationEnabled types.Bool   `tfsdk:"iam_database_authentication_enabled"`
	IamRoles                         types.Set    `tfsdk:"iam_roles"`
	ID                               types.String `tfsdk:"id"`
	Iops                             types.Int64  `tfsdk:"iops"`
	KmsKeyID                         fwtypes.ARN `tfsdk:"kms_key_id"`
	MasterPassword                   types.String `tfsdk:"master_password"`
	MasterUsername                   types.String `tfsdk:"master_username"`
	NetworkType                      types.String `tfsdk:"network_type"`
	OptionGroupName                      types.String `tfsdk:"option_group_name"`
	Port                             types.Int64  `tfsdk:"port"`
	PreferredBackupWindow            types.String `tfsdk:"preferred_backup_window"`
	PreferredMaintenanceWindow       types.String `tfsdk:"preferred_maintenance_window"`
	ReaderEndpoint                   types.String `tfsdk:"reader_endpoint"`
	ReplicationSourceIdentifier      types.String `tfsdk:"replication_source_identifier"`
	S3Import types.List `tfsdk:"s3_import"`
	ScalingConfiguration types.List `tfsdk:"scaling_configuration"`
	ServerlessV2ScalingConfiguration types.List `tfsdk:"serverlessv2_scaling_configuration"`
	SkipFinalSnapshot                types.Bool   `tfsdk:"skip_final_snapshot"`
	SnapshotIdentifier               types.String `tfsdk:"snapshot_identifier"`
	SourceRegion                     types.String `tfsdk:"source_region"`
	StorageEncrypted                 types.Bool   `tfsdk:"storage_encrypted"`
	StorageType                      types.String `tfsdk:"storage_type"`
	Tags                             types.Map    `tfsdk:"tags"`
	TagsAll                          types.Map    `tfsdk:"tags_all"`
	VpcSecurityGroupIds              types.Set    `tfsdk:"vpc_security_group_ids"`

	Timeouts timeouts.Value `tfsdk:"timeouts"`
}

type s3Import struct {
	BucketName types.String	`tfsdk:"bucket_name"`
	BucketPrefix types.String `tfsdk:"bucket_prefix"`
	IngestionRole types.String `tfsdk:"ingestion_role"`
	SourceEngine types.String `tfsdk:"source_engine"`
	SourceEngineVersion types.String `tfsdk:"source_engine_version"`
}

type scalingConfiguration struct {
	AutoPause types.Bool `tfsdk:"auto_pause"`
	MaxCapacity types.Int64 `tfsdk:"max_capacity"`
	MinCapacity types.Int64 `tfsdk:"min_capacity"`
	SecondsUntilAutoPause types.Int64 `tfsdk:"seconds_until_auto_pause"`
	TimeoutAction types.String `tfsdk:"timeout_action"`
}

type serverlessV2ScalingConfiguration struct {
	MaxCapacity types.Float64 `tfsdk:"max_capacity"`
	MinCapacity types.Float64 `tfsdk:"min_capacity"`
}

var (
	s3ImportAttrTypes = map[string]attr.Type{
		"bucket_name": types.StringType,
		"bucket_prefix": types.StringType,
		"ingestion_role": types.StringType,
		"source_engine": types.StringType,
		"source_engine_version": types.StringType,
	}

	scalingConfigurationAttrTypes = map[string]attr.Type{
		"auto_pause": types.BoolType,
		"max_capacity": types.Int64Type,
		"min_capacity": types.Int64Type,
		"seconds_until_auto_pause": types.Int64Type,
		"timeout_action": types.StringType,
	}

	serverlessV2ScalingConfigurationAttrTypes = map[string]attr.Type{
		"max_capacity": types.Float64Type,
		"min_capacity": types.Float64Type,
	}
)